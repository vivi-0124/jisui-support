# レシピ取得のロジックを説明
_Exported on 2025/7/6 at 0:32:34 JST from Cursor (1.2.1)_

---

**User**

レシピ取得の精度が良くないのでロジックを見直したいです。今一度ロジックの解説をしてください。

---

**Cursor**

現在のレシピ取得ロジックを解説するために、関連するファイルを確認して現在の実装を分析しましょう。

現在のレシピ取得ロジックを詳しく解説します。

## 現在のレシピ取得ロジック

### 1. 抽出メソッドの優先順位

現在のシステムは以下の優先順位でレシピを抽出します：

1. **データベースからの取得** (`database`) 
   - すでに処理された動画は再処理を避けるため
   - ユーザーがログインしている場合のみ

2. **Gemini AI動画分析** (`gemini_video_analysis`)
   - 最も精度が高い方法
   - 動画ファイルを直接分析
   - Gemini 1.5 Proを使用

3. **Gemini AIテキスト分析** (`gemini_text_analysis`)
   - 動画分析が失敗した場合のフォールバック
   - タイトルと説明文から抽出
   - Gemini 1.5 Flashを使用

4. **説明文パース** (`description`)
   - 最もシンプルな方法
   - 正規表現とキーワードマッチング

### 2. 各メソッドの詳細

#### 2.1 動画分析 (`analyzeVideoWithGemini`)
```typescript
// 動画URLを直接Geminiに送信
const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
const result = await model.generateContent([
  { text: prompt },
  { fileData: { mimeType: 'video/*', fileUri: videoUrl } }
]);
```

**問題点:**
- YouTube動画URLを直接Geminiに送信していますが、実際にはGeminiは公開URLの動画を直接分析できません
- この方法はエラーになる可能性が高い

#### 2.2 テキスト分析 (`analyzeTextWithGemini`)
```typescript
const prompt = `
タイトル: ${videoDetails.title}
説明文: ${videoDetails.description}
チャンネル名: ${videoDetails.channelTitle}

// 推測で補完、最低5つの材料と手順を含める
`;
```

**問題点:**
- 推測で情報を補完するため、実際の動画内容と異なる可能性
- 説明文に詳細が不足している場合、不正確な情報を生成

#### 2.3 説明文パース (`extractRecipeFromDescription`)
```typescript
// セクション判定
if (lowerLine.includes('材料') || lowerLine.includes('ingredient')) {
  currentSection = 'ingredients';
}
// 材料抽出
if (line.match(/[・•\-\*]/) || line.match(/\d+/) || 
    line.match(/(g|ml|個|本|枚|袋|パック|大さじ|小さじ|カップ|適量|少々)/)) {
  // 材料として認識
}
```

**問題点:**
- 非常に単純な正規表現マッチング
- 構造化されていない説明文に対して不正確
- 多言語対応が不十分

### 3. 主な問題点

1. **動画分析の技術的問題**
   - YouTube動画URLを直接Geminiに送信しているが、実際には動作しない
   - 代替手段として字幕や音声の抽出が必要

2. **テキスト分析の精度問題**
   - 推測による情報補完が不正確
   - 説明文の構造を十分に解析していない

3. **正規表現の限界**
   - 単純なパターンマッチング
   - 複雑な料理名や材料名に対応できない

4. **多言語対応の不足**
   - 日本語以外の動画に対する処理が不十分

### 4. 改善提案

1. **動画分析の修正**
   - YouTube Data APIから字幕データを取得
   - 音声を文字起こしして分析

2. **テキスト分析の改善**
   - より詳細なプロンプト設計
   - 段階的な情報抽出

3. **正規表現の強化**
   - より複雑なパターンマッチング
   - 料理データベースとの照合

4. **エラーハンドリング強化**
   - 各段階での適切なフォールバック
   - ユーザーフィードバックの活用

現在のロジックで最も問題となっているのは、動画分析部分のYouTube URL直接送信です。これを修正することで、大幅に精度向上が期待できます。

どの部分から改善を始めたいでしょうか？

```typescript
// 動画URLを直接Geminiに送信
const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
const result = await model.generateContent([
  { text: prompt },
  { fileData: { mimeType: 'video/*', fileUri: videoUrl } }
]);
```

```typescript
const prompt = `
タイトル: ${videoDetails.title}
説明文: ${videoDetails.description}
チャンネル名: ${videoDetails.channelTitle}

// 推測で補完、最低5つの材料と手順を含める
`;
```

```typescript
// セクション判定
if (lowerLine.includes('材料') || lowerLine.includes('ingredient')) {
  currentSection = 'ingredients';
}
// 材料抽出
if (line.match(/[・•\-\*]/) || line.match(/\d+/) || 
    line.match(/(g|ml|個|本|枚|袋|パック|大さじ|小さじ|カップ|適量|少々)/)) {
  // 材料として認識
}
```

---

**User**

gemini-2.5-flash にしてみて。

---

**Cursor**

現在のGeminiモデルを `gemini-2.5-flash` に変更します。

```typescript
async function analyzeVideoWithGemini(
  videoId: string,
  videoDetails: {
    title: string;
    description: string;
    channelTitle: string;
    thumbnail: string;
  },
  apiKey: string
): Promise<ExtractedRecipe> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-1.5-pro' });

->

async function analyzeVideoWithGemini(
  videoId: string,
  videoDetails: {
    title: string;
    description: string;
    channelTitle: string;
    thumbnail: string;
  },
  apiKey: string
): Promise<ExtractedRecipe> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
```

```typescript
async function analyzeTextWithGemini(
  videoDetails: {
    title: string;
    description: string;
    channelTitle: string;
    thumbnail: string;
  },
  apiKey: string
): Promise<ExtractedRecipe> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

->

async function analyzeTextWithGemini(
  videoDetails: {
    title: string;
    description: string;
    channelTitle: string;
    thumbnail: string;
  },
  apiKey: string
): Promise<ExtractedRecipe> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
```

Geminiモデルを `gemini-2.5-flash` に変更しました。

## 変更内容

1. **動画分析関数** (`analyzeVideoWithGemini`)
   - `gemini-1.5-pro` → `gemini-2.5-flash`

2. **テキスト分析関数** (`analyzeTextWithGemini`)
   - `gemini-1.5-flash` → `gemini-2.5-flash`

## Gemini 2.5 Flash の特徴

- **最新モデル**: より高性能で精度の高い分析が期待できます
- **高速処理**: Flashモデルなので処理速度が向上します
- **コスト効率**: ProモデルよりもコストEfficient

これで両方の分析関数で統一された最新のGeminiモデルを使用するようになりました。レシピ抽出の精度向上が期待できます。

動画分析の方で発生していた技術的問題（YouTube URL直接送信）については、別途修正が必要ですが、まずは最新モデルでの改善効果を確認してみてください。

---

**User**

Youtubeの利用規約です。このアプリは利用規約を守っていますか？


利用規約

利用規約を他の言語で表示: English、日本語

規約の内容

この概要索引は、YouTube の利用規約（規約）の確認にお役立ていただくことを目的としています。ご理解の一助となれば幸いですが、必ず規約の全文をお読みいただくようお願いいたします。

YouTube へようこそ

このセクションでは、YouTube とお客様との関係についてまとめています。本サービスの説明、本契約の定義、サービスの提供者の名称などが含まれます。

本サービスの利用者

このセクションでは、本サービスを利用するための条件を明確にし、ユーザーのカテゴリを定義します。

本サービスの利用

このセクションでは、本サービスを利用する権利と、本サービス利用時に適用される条件について説明します。また、YouTube が本サービスを変更する方法についても説明します。

お客様のコンテンツと行動

このセクションは、本サービスにコンテンツを提供するお客様が対象です。コンテンツをアップロードすることで YouTube に付与することになる許諾の範囲を明確にし、他人の権利を侵害するコンテンツをアップロードしないことへの同意を規定しています。

アカウントの停止と解除

このセクションでは、どのようにしてお客様または YouTube が互いの関係を解消できるかについて解説しています。

本サービスで使用するソフトウェアについて

このセクションでは、本サービスで使用するソフトウェアの詳細について取り上げています。

その他の法的条項

このセクションは、両当事者の法的な義務についての規定を含んでいます。います。また、YouTube が免責される事柄についても説明します。

本契約について

このセクションでは、規約を変更する場合についての説明や、規約に適用される法律など、本契約に関するその他の重要な事項を取り上げます。

利用規約

日付: 2023年6月1日

利用規約

YouTube へようこそ

はじめに

YouTube のプラットフォームおよびその一部として提供しているプロダクト、サービス、機能（以下「本サービス」）をご利用いただきありがとうございます。

本サービス

本サービスでは、動画やその他のコンテンツを発見、視聴、共有できます。また、本サービスは世界中の人々がつながり、情報を共有し、刺激を与え合う場所であり、規模を問わずオリジナル コンテンツのクリエイターや広告主が、動画や広告を配信できる場所でもあります。プロダクトについての情報とそれらの使用方法は、ヘルプセンターに詳しく記載しています。YouTube Kids、YouTube パートナー プログラム、YouTube 有料メンバーシップとその購入（利用可能な場合）に関する情報もヘルプセンターでご確認いただけます。テレビやゲーム機、Google Home などの他のデバイスでのコンテンツの視聴について詳しく解説した記事もあります。

 

本サービスの提供者

本サービスは、デラウェア州法に基づいて事業を行い、1600 Amphitheatre Parkway, Mountain View, CA 94043 に所在する Google LLC（以下「YouTube」または「Google」）が提供します。本規約において YouTube の「関係会社」とは、Alphabet Inc. の現在または将来の企業グループ内の他の企業を意味します。

適用される規約

本サービスの利用には、本規約、YouTube コミュニティ ガイドラインおよびポリシー、セキュリティ、著作権のポリシー（以下、あわせて「本契約」）が適用されます。本契約は随時更新されることがあります。本サービスの広告主またはスポンサーになる場合や、コンテンツに有料プロモーションを組み込む場合は、本契約に広告主向けの広告ポリシーも含まれることになります。本規約に記載されるその他のリンクや参考資料はすべて、情報の提供のみを目的とするものであって、本契約を構成するものではありません。

本契約をよくお読みになり、十分に理解してください。本契約の記載内容を理解または承諾いただけない場合には、本サービスをご利用いただけません。

本サービスの利用者

年齢に関する要件

本サービスを利用するには、13 歳以上である必要があります。ただし、親または保護者によって有効にされていれば、あらゆる年齢のお子様に 本サービスおよび YouTube Kids （利用可能な地域の場合）をご利用いただけます。

親または保護者による許可

お住まいの国や地域で未成年と見なされるユーザーは、本サービスの利用について親または保護者の許可を得ていることを表明するものとします。本契約を親または保護者と一緒にお読みください。

お住まいの国や地域で未成年と見なされるユーザーの親または保護者である方は、お子様が本サービスを利用することを許可することにより、本契約の規定の対象となり、本サービスでのお子様の行為について責任を負うことになります。13歳未満のお子様の本サービスおよびYouTube Kidsの利用を可能とする方法を含む、YouTube をご家族で安全にご利用いただくためのツールやリソースを、ヘルプセンターの保護者向けリソースや Google のファミリー リンクから入手できます。

事業用の利用

お客様は、本サービスを会社や組織のために使用する場合、当該会社や組織のために行為する権限を有していること、および当該会社や組織が本契約に同意していることを表明するものとします。

本サービスの利用

本サービスのコンテンツ

本サービスのコンテンツには、動画、オーディオ（音楽やその他のサウンドなど）、画像、写真、言語（コメントや脚本など）、ブランド表示（商号、商標、サービスマーク、ロゴなど）、インタラクティブ機能、ソフトウェア、指標、および、お客様、YouTubeまたは第三者によって提供される素材などがあります（以下、総称して「コンテンツ」）。

コンテンツに対する責任は、そのコンテンツを本サービスに提供した人物や組織が負うものとします。YouTube はコンテンツをホストまたは提供する義務を負いません。お客様は、コミュニティ ガイドラインや法令への違反を含め、本契約を遵守していないと思われるコンテンツを見つけた場合、YouTube に報告できます。

Google アカウントと YouTube チャンネル

コンテンツの閲覧や検索など、本サービスの一部は Google アカウントがなくても利用できますが、Google アカウントが必要な機能もあります。Google アカウントがあれば、動画を高く評価したり、チャンネル登録したり、自分の YouTube チャンネルを作成したりできます。Google アカウントを作成するには、こちらのページの手順に従ってください。

YouTube チャンネルを作成すると、動画のアップロード、コメントの書き込み、再生リストの作成（利用可能な場合）など、より多くの機能を利用できるようになります。YouTube チャンネルの作成方法について詳しくは、こちらをご覧ください。

Google アカウントを保護するため、パスワードは他人に知らせないでください。Google アカウントのパスワードを第三者のアプリケーションで再利用することは避けてください。詳しくは、アカウントのセキュリティを強化するをご覧ください。パスワードや Google アカウントの不正利用が疑われる場合の対処方法についても記載されています。

お客様の情報

プライバシー ポリシーでは、本サービスの利用におけるお客様の個人データの取り扱いとプライバシーの保護について記載しています。YouTube Kids のプライバシー ポリシーでは、YouTube Kids に特化したプライバシーへの取り組みについて詳しく解説しています。

YouTube は、お客様が個人的または家庭内で利用するためにアップロードした場合を除き、アップロードされた音声コンテンツや映像と音声のコンテンツを YouTube データ処理規約に従って処理します。詳しくはこちらをご覧ください。

許可と制限事項

お客様は、本契約および適用される法律を遵守する限り、本サービスにアクセスして利用できます。お客様は個人的で、非営利目的の用途でコンテンツを視聴できます。また、埋め込み型 YouTube プレーヤーに YouTube 動画を表示させることもできます。

本サービスの利用には制限があり、以下の行為が禁止されています。

本サービスまたはコンテンツのいずれかの部分に対しても、アクセス、複製、ダウンロード、配信、送信、放送、展示、販売、ライセンス供与、改変、修正、またはその他の方法での使用を行うこと。ただし、（a）本サービスによって明示的に承認されている場合、または（b）YouTube および（適用される場合）各権利所持者が事前に書面で許可している場合を除きます。

本サービスのいずれかの部分を迂回、無効化、不正利用、またはその他の方法で妨害すること（またはこれらのいずれかを試みること）。なお、この「本サービスのいずれかの部分」には、セキュリティ関連の機能、または（a）コンテンツのコピーもしくはその他の利用法を防止もしくは制限する機能、もしくは（b）本サービスもしくはコンテンツの利用を制限する機能が含まれます。

自動化された手段（ロボット、ボットネット、スクレーパなど）を使用して本サービスにアクセスすること。ただし、（a）公開されている検索エンジンを YouTube の robots.txt ファイルに従って使用する場合、または（b）YouTube が事前に書面で許可している場合を除きます。

個人を特定できる可能性のある情報（例えば、ユーザー名、顔の映像や画像など）を収集または取得すること。ただし、その人物が許可している場合および本項第３号で認められている場合を除きます。

ユーザーの意向を無視した宣伝または営利目的のコンテンツを配信したり、一方的な勧誘や大量の勧誘を行ったりするために本サービスを使用すること。

本来のユーザー エンゲージメントの測定結果を歪めること、またはそのように仕向けること。たとえば、ユーザーに金銭を支払ったりインセンティブを与えたりして、動画の視聴回数、高評価数、低評価数を増やす、チャンネル登録者を増やす、またはその他なんらかの方法で指標を操作することなどが含まれます。

報告、フラグ立て、申し立て、異議申し立て、または再審査請求のプロセスを不正使用すること。これには、根拠のない、濫用的な、または嫌がらせ的な申請なども含まれます。

本サービス上で、または本サービスを通して、YouTube コンテストのポリシーとガイドラインに従っていないコンテストを実施すること。

本サービスを個人的、非営利的な用途以外でコンテンツを視聴するために利用すること（たとえば、不特定または多数の人のために、本サービスの動画を上映したり、音楽をストリーミングしたりすることはできません）。

本サービスを利用して、（a）広告主向けの広告ポリシーで許可されているもの（準拠したプロダクト プレースメントなど）を除き、本サービスまたはコンテンツ上、その周囲、もしくはその内部でなんらかの広告、スポンサーシップ、プロモーションを販売すること、または（b）以下のいずれかに該当する広告、スポンサーシップもしくはプロモーションを販売すること。(i) 本サービスからの取得したコンテンツのみで構成されたウェブサイトまたはアプリケーションのページに掲載される広告、スポンサーシップもしくはプロモーションの販売、もしくは (ii) 本サービスからのコンテンツを主な根拠とする広告、スポンサーシップ、もしくはプロモーションの販売（たとえば YouTube 動画がユーザー集客の目玉であるウェブページなどに掲載される広告を販売すること）。

留保

本サービスの利用により、ユーザー名や他のユーザーが YouTube に投稿したコンテンツを含め、本サービスのなんらかの要素に関する財産権その他の権利がお客様に付与されることはありません。

本サービスの開発、改善、更新

YouTube は常に本サービスの変更と改善を行っています。より優れたサービスの提供に向けたこの継続的な取り組みの一環として、YouTube は（本サービスの全部または一部に）修正や変更を加えることがあります。たとえば、機能の追加や廃止、新しいデジタル コンテンツやサービスの提供、古いデジタル コンテンツやサービスの終了などを行うことがあります。パフォーマンスやセキュリティの改善、機能の変更、法令遵守のための変更、またはシステムを利用した違法行為や不正行為の防止のため、本サービスやその一部を変更または廃止する必要が生じることがあります。この変更により、すべてのユーザー、一部のユーザー、または特定のユーザーに影響が及ぶ可能性があります。 本サービスがダウンロード可能なソフトウェア（YouTube Studio アプリケーションなど）を必要とする、または含んでいる場合、お使いのデバイスにインストールされた当該ソフトウェアは、新バージョンまたは新機能が入手可能になり次第、自動更新されることがあります（ただし、お使いのデバイスの設定に従います）。ユーザーの本サービスの利用に悪影響を及ぼす重大な変更を行う場合、YouTube はユーザーに対して合理的な事前通知を行います。ただし、不正行為の防止、法的要件に対応する必要がある、またはセキュリティや運営上の問題に対処する必要があるなどの緊急時は除きます。また、こうした場合、適用される法律およびポリシーを条件として、Google データ エクスポートを使用して Google アカウントからユーザーのコンテンツをエクスポートする機会を提供します。

お客様のコンテンツと行動

コンテンツのアップロード

お客様が YouTube チャンネルをお持ちの場合、本サービスにコンテンツをアップロードできます。ご自分のコンテンツを活用して、ビジネスや芸術活動を宣伝できます。コンテンツをアップロードする際、本契約（YouTube のコミュニティ ガイドラインを含みます）や法律を遵守していないコンテンツを本サービスに投稿することはできません。たとえば、権利所有者から許諾を得ている、または法的な権限がある場合を除いて、第三者の知的所有権（著作物など）を含むコンテンツは投稿できません。お客様は、本サービスに投稿するコンテンツに法的な責任を負います。YouTube は、スパム、マルウェア、違法コンテンツなどの侵害や悪用行為を検出するために、お客様のコンテンツを自動で分析するシステムを使用することがあります。

お客様が付与する権利

お客様は、ご自身のコンテンツに対する所有権を保持します。ただし、YouTube に対して、および本サービスを利用する他のユーザーに対して、以下の一定の権利を付与していただく必要があります。

YouTube へのライセンス付与

本サービスにコンテンツを提供することにより、お客様は YouTube に対して、本サービスならびに YouTube（とその承継人および関係会社）の事業に関連して当該コンテンツを使用（複製、配信、派生的著作物の作成、展示および上演を含みます）するための世界的、非独占的、サブライセンスおよび譲渡可能な無償ライセンスを付与するものとします。これには、本サービスの一部または全部を宣伝または再配布することを目的とした使用も含まれます。

他のユーザーへのライセンス付与

また、お客様は、本サービスを利用する他の各ユーザーに対して、本サービスを通じてコンテンツにアクセスし、（動画の再生や埋め込みなど）本サービスの機能によってのみ可能な方法で、複製、配信、派生的著作物の作成、展示、上演などのかたちでコンテンツを使用する世界的、非独占的な無償ライセンスを付与するものとします。明確にするために付記すると、このライセンスは、本サービスから独立した方法でコンテンツを使用する権利や権限を与えるものではありません。

ライセンスの有効期限

お客様が付与するライセンスは、お客様が本サービスからコンテンツを削除した後も、商業的に合理的な期間にわたって存続します。ただし、お客様が削除した動画のサーバーコピーを YouTube が保持する可能性があることをお客様は理解し、同意するものとします。この場合、YouTube に保持される動画が表示、配信、上演されることはありません。

収益化に関する権利

お客様は、本サービスにおけるコンテンツの収益化に関する権利を YouTube に付与します（収益化には、コンテンツ上やコンテンツ内で広告を表示すること、あるいはアクセスの手数料をユーザーに請求することが含まれます）。本規約は、お客様に支払いを受ける権利を付与するものではありません。2021 年 6 月 1 日以降、YouTube との間の他の契約により YouTube から支払いを受け取る資格をクリエイターの方が有する場合（YouTube パートナー プログラム、チャンネル メンバーシップ、Super Chat などによる支払いを含みます）、そのような支払いはロイヤルティとして扱われるようになります。法律上義務付けられている場合、Google はこのような支払いから源泉徴収を行います。

コンテンツの削除

お客様はいつでも本サービスから自分の動画を削除できます。削除する前にコンテンツをダウンロードすることもできます。規約で定められている権利を失った場合には、コンテンツを削除しなければなりません。

YouTube によるコンテンツの削除

YouTube は、以下のいずれかに該当すると合理的に判断する場合、独自の裁量によりコンテンツを削除する権利を留保します。(1) コンテンツが本契約に違反している、または、(2) コンテンツが YouTube、ユーザー、もしくは第三者に損害を及ぼす可能性がある。削除する場合、YouTube はその理由とともに通知します。ただし、通知を行うことにより（a）法律もしくは法執行機関の指示に違反する、または YouTube もしくは YouTube の関係会社が法的な責任を果たせなくなる、（b）本サービスの調査、完全性、運用に支障が生じる、（c）ユーザー、第三者、YouTube、YouTube の関係会社のいずれかに損害を及ぼすと合理的に判断される場合を除きます。再審査請求を行う方法など、報告や違反措置についての詳細は、ヘルプセンターのトラブルシューティングのページをご覧ください。

コミュニティ ガイドライン違反警告

YouTube では、YouTube コミュニティ ガイドラインに違反したコンテンツに関して、「違反警告」を発するシステムを運用しています。違反警告ごとにさまざまな制限が通知され、お客様のチャンネルが YouTube から永久に削除されることもあります。違反警告を受けるとお客様のチャンネルにどのような影響が及ぶのかについて、詳しくはコミュニティ ガイドラインの違反警告に関する基礎知識のページをご覧ください。違反警告が誤って発せられたと思われる場合は、異議を申し立てることができます。

違反警告を理由にお客様のチャンネルが制限された場合に、その制限を迂回する目的で別のチャンネルを使用することは禁止されています。この禁止事項の違反は本契約の重大な違反となり、Google はお客様の Google アカウントまたは本サービスの全部もしくは一部へのアクセスを停止する権利を有します。

著作権の保護

著作権者がオンライン上で知的財産権を管理するために役立つ情報を、YouTube 著作権センターで提供しています。本サービス上で自分の著作権が侵害されていると思われる場合は、YouTube に通知してください。

通知を受けた YouTube は、YouTube 著作権センターに掲載されている手続きに従って著作権侵害の申し立てに対応します。YouTube 著作権センターには、著作権侵害の警告を解決する方法も掲載されています。YouTube のポリシーでは、侵害行為を繰り返すユーザーについては、状況に応じて本サービスへのアクセスを解除することが定められています。

アカウントの停止と解除

お客様による解除

お客様はいつでも本サービスの利用を止めることができます。Google アカウントから本サービスを削除するには、こちらの手順に従ってください。これにより YouTube チャンネルが閉鎖され、データも削除されます。削除前にデータのコピーをダウンロードすることもできます。

YouTube による解除と停止

（a）お客様による本契約への違反が深刻である、もしくは繰り返される場合、（b）法的義務もしくは裁判所の命令に従うために必要である場合、または（c）他のユーザー、第三者、YouTube、YouTube の関係会社のいずれかに不利益または損害を与える（もしくはその可能性がある）行為が行われていると YouTube が判断する場合、YouTube は、お客様の Google アカウントまたはお客様の本サービスの全部もしくは一部へのアクセスを停止または解除する権利を留保します。 

解除、停止に関する通知

YouTube による解除または停止が行われる場合、YouTube はその理由とともに通知します。ただし、通知を行うことにより（a）法律もしくは法執行機関の指示に違反する、（b）調査に支障をきたす、（c）本サービスの完全性、運用、セキュリティに支障が生じる、または、（d）他のユーザー、第三者、YouTube、YouTube の関係会社のいずれかに損害を及ぼすと合理的に判断される場合を除きます。

アカウントの停止または解除による影響

お客様の Google アカウントが解除された場合、またはお客様の本サービスへのアクセスが制限された場合でも、本サービスの一部分（再生のみの利用など）はアカウントなしで引き続き利用できます。また、そのような場合でも引き続き本契約が適用されます。解除または停止が誤って行われたと思われる場合は、こちらのフォームから再審査を請求できます。

本サービスで使用するソフトウェアについて

ダウンロード可能なソフトウェア

本サービスがダウンロード可能なソフトウェア（YouTube Studio アプリケーションなど）を必要とする、または含んでいる場合、当該ソフトウェアがライセンス供与を伴う追加規約に準拠する場合を除いて、YouTube は YouTube が本サービスの一部としてお客様に提供するソフトウェアについて、世界的、譲渡不可能、非独占的な個人使用の無償ライセンスをお客様に付与します。このライセンスは、YouTube が提供する本サービスのメリットを、お客様が本契約で許可されている方法で使用および享受できるようにすることを唯一の目的とします。ソフトウェアの全部または一部の複製、変更、配信、販売、貸与、またはソフトウェアのソースコードのリバース エンジニアリングもしくは抽出は禁止されています。ただし、法律によってそのような制限が禁止されている場合や、YouTube が書面で許可する場合を除きます。

オープンソース

本サービスで使用されているソフトウェアの一部は、YouTube が提供するオープンソース ライセンスに基づいて提供されます。このオープンソース ライセンスには、本規約の一部の規定に優先することを明示した条項が含まれていることがあるので、必ずライセンスに目を通しておくようにしてください。

その他の法的条項

保証に関する免責条項

本契約で明示的に規定されている場合や法律上義務付けられている場合を除き、本サービスは現状有姿で提供され、YouTube は本サービスについて具体的な約束や保証を行いません。たとえば、（a）本サービスを通じて提供されるコンテンツ、（b）本サービスの特定の機能、その正確性、信頼性、可用性、ニーズに応える能力、（c）お客様が送信したコンテンツを本サービスでアクセスできるようにすることについて、YouTube はいかなる保証も行いません。

責任の制限

法律により義務付けられる場合または故意もしくは重大な過失に基づく責任の場合を除いて、YouTube、YouTubeの関係会社、役員、取締役、従業員、代理人は、以下のことに起因する利益、収入、ビジネスの機会、のれん、または予想される利得についての損失、およびデータの紛失や破損、間接的または結果的な損失、懲罰的損害賠償について一切の責任を負いません。

本サービスのエラー、誤り、不正確さ

お客様が本サービスを利用したことに起因する人身傷害または物的損害

本サービスへの不正アクセスまたは本サービスの不正利用

本サービスの中断または停止

第三者により本サービスに対して、または本サービスを通じて送信されるウィルスまたは悪意のあるコード

お客様によるコンテンツの使用を含む、ユーザーまたは YouTube が送信したコンテンツ

コンテンツの削除またはアクセス不能

この条項は、保証、契約、不法行為その他いかなる法的理論に基づく請求であるかどうかにかかわらず、あらゆる請求に適用されます。

適用される法律で認められる範囲で、本サービスに起因または関連する申し立てについて YouTube および YouTube の関係会社が負う責任の総額は、（a）お客様が書面により YouTube に対して請求を通知した日までの 12 か月間における本サービスの使用により YouTube がお客様に支払った収益と、（b）500 米ドルのいずれか高額な方を上限とします。

補償

適用される法律で認められる範囲で、お客様は（i）お客様による本サービスの使用および本サービスへのアクセス、（ii）お客様による本契約のいずれかの規定への違反、（iii）お客様による第三者の権利（著作権、財産権、プライバシー権を含むがこれらに限定されない）の侵害、（iv）お客様のコンテンツが第三者に損害を与えたという主張のいずれかに起因するあらゆる申し立て、損害、義務、損失、責任、コスト、債務、費用（弁護士費用を含みますがこれに限定されません）に関し、いかなる場合においても YouTube および YouTube の関係会社、役員、取締役、従業員、代理人を防御し、補償し、免責することに同意するものとします。保護と補償に関するこの義務は、本契約が終了し、お客様が本サービスを利用しなくなっても存続します。

第三者のリンク

本サービスには、YouTube によって所有も管理もされていない第三者のウェブサイトおよびオンライン サービスへのリンクが含まれている場合があります。YouTube は、こうしたウェブサイトおよびオンライン サービスを管理しておらず、一切責任を負いません。本サービスから離れる際はご注意ください。利用する第三者のウェブサイトやオンライン サービスの規約とプライバシー ポリシーを一読することをおすすめします。

本契約について

本契約の変更

YouTube は、たとえば、（1）サービスの変更、または業務運営上の変更を反映するため（たとえば、サービスや機能を新しく追加、もしくは従来のものを削除した場合など）、（2）法律、規制、セキュリティ上の理由のため、（3）不正または危険な行為を防ぐために、本契約を変更することがあります。

本契約に重大な変更を加える場合は、お客様に合理的な事前通知を行い、変更について確認する機会を提供します。ただし、（1）新製品または新機能をリリースする場合、または、（2）緊急時（進行中の不正行為を止める必要がある場合、法的要件に対応する必要がある場合など）は除きます。お客様は新しい規約に同意しない場合、アップロードしたコンテンツを削除して本サービスの利用を停止するものとします。

本契約の継続

お客様による本サービスの利用が終了した後も、本契約の「その他の法的条項」と「本契約について」の各規定は引き続きお客様に適用されます。また、お客様が付与したライセンスは「ライセンスの有効期限」の規定に従って継続します。

分離可能性

なんらかの理由により本契約の特定の規定が効力を持たないことが判明した場合であっても、そのことは他のいずれの規定にも影響を及ぼすものではありません。

権利の非放棄

お客様が本契約を遵守しない場合に、YouTube が直ちに措置を講じないことがあったとしても、そのことによって YouTube が有している権利（たとえば、将来において、法的措置を講じる権利）を放棄しようとしていることを意味するものではありません。

解釈

本規約において、「含みます」または「含まれます」とは、「含みますが、それらに限定されません」という意味です。また、すべての例は説明のみを目的としたものです。

準拠法

本規約または本サービスに起因または関連して生じるすべての申し立てについては、カリフォルニア州法が適用されるものとし（ただしカリフォルニア州の抵触法の規則を除く）、米国カリフォルニア州サンタクララ郡の連邦裁判所または州裁判所においてのみ訴訟を起こすことができます。お客様と YouTube はこれらの裁判所の対人管轄権に同意するものとします。

2023年6月1日 発効（ 以前のバージョンを表示 ）

---

**Cursor**

YouTube の利用規約を拝見しました。現在お使いのアプリケーションがこの利用規約を遵守しているかについて、主な論点と合わせてご説明します。

全体的に見て、このアプリが YouTube Data API を使用して動画のメタデータを取得している点は問題ありません。しかし、**`src/app/api/youtube/extract-recipe/route.ts` ファイル内の `analyzeVideoWithGemini` 関数における動画コンテンツの直接利用が、YouTube の利用規約に違反する可能性が非常に高い**です。

### 違反の可能性がある主なポイント

#### 1. コンテンツの無許可なアクセス、複製、使用の禁止

利用規約には以下の記述があります。

> 本サービスまたはコンテンツのいずれかの部分に対しても、アクセス、複製、ダウンロード、配信、送信、放送、展示、販売、ライセンス供与、改変、修正、またはその他の方法での使用を行うこと。ただし、（a）本サービスによって明示的に承認されている場合、または（b）YouTube および（適用される場合）各権利所持者が事前に書面で許可している場合を除きます。

現在の `analyzeVideoWithGemini` 関数では、YouTube の動画 URL を直接 Gemini AI に渡しています。

```typescript
// src/app/api/youtube/extract-recipe/route.ts
async function analyzeVideoWithGemini(...) {
  // ...
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const result = await model.generateContent([
    { text: prompt },
    { fileData: { mimeType: 'video/*', fileUri: videoUrl } } // ★この部分
  ]);
  // ...
}
```

これは、YouTube が提供する公式 API (YouTube Data APIなど) を介さずに、動画コンテンツ自体に直接アクセスし、AI で処理しようとする行為と見なされる可能性が高いです。YouTube Data API は動画のメタデータ（タイトル、説明、サムネイルなど）の取得を目的としており、動画ストリームそのものの直接利用は通常、明示的に許可されていません。この直接的な動画コンテンツの利用は、上記の利用規約に抵触する恐れがあります。

#### 2. 自動化された手段によるアクセス（スクレイピングの禁止）

利用規約には以下の記述があります。

> 自動化された手段（ロボット、ボットネット、スクレーパなど）を使用して本サービスにアクセスすること。ただし、（a）公開されている検索エンジンを YouTube の robots.txt ファイルに従って使用する場合、または（b）YouTube が事前に書面で許可している場合を除きます。

YouTube Data API を使用している場合、それは「書面で許可されている場合」に該当すると考えられますが、動画 URL を直接 AI に渡す行為は、API の範囲を超えた「自動化された手段によるアクセス」と解釈される可能性もあります。

### その他のポイント

- **個人的、非営利的な用途での利用:** アプリがレシピ管理という個人的な用途を目的としている場合、抽出されたレシピの利用自体は「個人的で、非営利目的の用途」に該当すると考えられます。ただし、抽出方法が規約に沿っていることが前提です。
- **コンテンツの所有権とライセンス:** 抽出されたレシピのデータは、元の YouTube 動画コンテンツの派生物と見なされる可能性があります。その派生物の利用や保存が、YouTube のライセンス要件に合致しているかどうかも考慮すべき点です。

### 結論と改善提案

現在の実装では、`analyzeVideoWithGemini` 関数が YouTube の利用規約に違反するリスクが非常に高いです。

**改善提案:**

1.  **動画分析機能の修正**: `analyzeVideoWithGemini` 関数で YouTube の動画 URL を直接 Gemini AI に渡すのではなく、以下のいずれかの方法を検討してください。
    *   **YouTube Data API v3 を活用する**: 動画の字幕（キャプション）データや音声認識されたテキストデータを API 経由で取得し、それを Gemini AI に渡して分析させる方法です。これにより、YouTube の利用規約に準拠した形でコンテンツの情報を取得できます。
    *   **動画の文字起こしサービスを利用する**: YouTube Data API で直接取得できない場合は、サードパーティの動画文字起こしサービスを利用し、そのテキストデータを Gemini AI に渡すことも考えられます。ただし、その場合も各サービスの利用規約を確認する必要があります。
    *   **`analyzeVideoWithGemini` 関数の削除または無効化**: もし動画の直接分析が現在のアプリケーションの要件として必須でない場合、この機能を削除するか、テキスト分析に完全にフォールバックするようにロジックを変更することを強く推奨します。

この修正を行うことで、アプリが YouTube の利用規約を遵守し、より安定した運用が可能になります。

```typescript
// src/app/api/youtube/extract-recipe/route.ts
async function analyzeVideoWithGemini(...) {
  // ...
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const result = await model.generateContent([
    { text: prompt },
    { fileData: { mimeType: 'video/*', fileUri: videoUrl } } // ★この部分
  ]);
  // ...
}
```

---

**User**

ouTube Data API v3で取得したデータをGemini AI で成形するのはどうかな？

---

**Cursor**

はい、YouTube Data API v3で取得したデータ（特に動画のタイトル、説明文、そして可能であれば字幕データ）をGemini AIで成形するというアプローチは、利用規約を遵守しつつレシピ抽出の精度を向上させる非常に良い方法です。

現在のコードでは、`analyzeTextWithGemini` 関数が既に動画のタイトルと説明文を使ってGemini AIにテキスト分析をさせています。この関数のプロンプトを調整することで、より精度の高いレシピ抽出を目指せます。

特に、現在の `analyzeTextWithGemini` のプロンプトには「説明文に記載されていない情報は推測で補完してください」「料理名から一般的な材料や手順を推測して追加してください」という指示が含まれており、これが「精度が悪い」と感じる原因になっている可能性があります。提供された情報のみに基づいて抽出するよう修正しましょう。

まず、`analyzeTextWithGemini` 関数内のプロンプトを修正し、推測を減らして、より厳密な情報抽出を行うように変更します。

---

### `src/app/api/youtube/extract-recipe/route.ts` の変更提案

`analyzeTextWithGemini` 関数のプロンプトを以下のように変更します。

```typescript
// src/app/api/youtube/extract-recipe/route.ts
// ... 既存のコード ...

async function analyzeTextWithGemini(
  videoDetails: {
    title: string;
    description: string;
    channelTitle: string;
    thumbnail: string;
  },
  apiKey: string
): Promise<ExtractedRecipe> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const prompt = `
以下のYouTube料理動画のタイトルと説明文から、料理のレシピ情報を抽出してください。
動画の内容を正確に反映し、説明文に明示的に記載されている情報のみを使用してください。

タイトル: ${videoDetails.title}
説明文: ${videoDetails.description}
チャンネル名: ${videoDetails.channelTitle}

以下の形式でJSONで回答してください：
{
  "ingredients": [
    "材料名 分量単位",
    "例: 玉ねぎ 1個",
    "例: 醤油 大さじ2"
  ],
  "steps": [
    "手順1の詳細な説明",
    "手順2の詳細な説明"
  ],
  "servings": "何人分",
  "cookingTime": "調理時間（分）"
}

重要な指示：
1. 材料は具体的な分量と単位を含めて記載してください。
2. 手順は順序立てて、具体的に記載してください。
3. **提供されたタイトル、説明文、字幕などの情報に基づき、明確に記載されている内容のみを抽出してください。**
4. **記載されていない情報は推測で補完しないでください。**
5. 日本語で回答してください。
6. レシピ情報が不足している場合でも、抽出できた部分のみを返却してください。

`;

  try {
// ... 既存のコード ...
```

---

この変更により、Geminiは提供されたテキスト情報に基づいて、より厳密なレシピ抽出を行うようになります。

### 今後の検討事項

-   **字幕データの活用**: YouTube Data API v3で動画の字幕データ（キャプション）を取得できる場合、それを`analyzeTextWithGemini`関数に渡すことで、レシピ抽出の精度をさらに向上させることができます。字幕データは動画の内容をより正確に反映しているため、レシピ情報が豊富に含まれている可能性があります。字幕データの取得については、YouTube Data API v3の公式ドキュメントを確認する必要があります。
-   **`analyzeVideoWithGemini`関数の扱い**: 現在の`analyzeVideoWithGemini`関数はYouTubeの利用規約に抵触する可能性が高いため、この関数を削除するか、字幕データを扱う形に完全に変更することを検討してください。

まず上記のプロンプト修正を適用します。よろしいでしょうか？

```typescript
// src/app/api/youtube/extract-recipe/route.ts
// ... 既存のコード ...

async function analyzeTextWithGemini(
  videoDetails: {
    title: string;
    description: string;
    channelTitle: string;
    thumbnail: string;
  },
  apiKey: string
): Promise<ExtractedRecipe> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const prompt = `
以下のYouTube料理動画のタイトルと説明文から、料理のレシピ情報を抽出してください。
動画の内容を正確に反映し、説明文に明示的に記載されている情報のみを使用してください。

タイトル: ${videoDetails.title}
説明文: ${videoDetails.description}
チャンネル名: ${videoDetails.channelTitle}

以下の形式でJSONで回答してください：
{
  "ingredients": [
    "材料名 分量単位",
    "例: 玉ねぎ 1個",
    "例: 醤油 大さじ2"
  ],
  "steps": [
    "手順1の詳細な説明",
    "手順2の詳細な説明"
  ],
  "servings": "何人分",
  "cookingTime": "調理時間（分）"
}

重要な指示：
1. 材料は具体的な分量と単位を含めて記載してください。
2. 手順は順序立てて、具体的に記載してください。
3. **提供されたタイトル、説明文、字幕などの情報に基づき、明確に記載されている内容のみを抽出してください。**
4. **記載されていない情報は推測で補完しないでください。**
5. 日本語で回答してください。
6. レシピ情報が不足している場合でも、抽出できた部分のみを返却してください。

`;

  try {
// ... 既存のコード ...
```

---

**User**

抽出メソッドの優先順位

1. データベースからの取得 (database)
2. Gemini AI動画分析 (gemini_video_analysis)
3. Gemini AIテキスト分析 (gemini_text_analysis)
4. 説明文パース (description)
今この４つだけど、

1. データベースからの取得 (database)
2.YouTube Data API v3 → Gemini AI 
この2つにしましょう。@route.ts 

---

**Cursor**

承知いたしました。現在のレシピ取得ロジックを、ご要望の通り「データベースからの取得」と「YouTube Data API v3 → Gemini AI」の2段階に簡素化します。

これにより、YouTubeの利用規約に準拠しつつ、推測に基づかない正確なレシピ抽出を目指します。

具体的には、以下の変更を `src/app/api/youtube/extract-recipe/route.ts` に加えます。

1.  **ロジックの簡素化**:
    *   `analyzeVideoWithGemini`（動画の直接分析）を削除します。
    *   `extractRecipeFromDescription`（単純なテキスト解析）を削除します。
    *   レシピ抽出は、YouTube Data APIで取得した情報を `analyzeTextWithGemini` で処理する方法に統一します。
2.  **精度の向上**:
    *   `analyzeTextWithGemini` のプロンプトを修正し、与えられた情報（タイトル、説明文）からのみレシピを抽出するように指示し、AIによる推測を抑制します。
3.  **型の整理**:
    *   ロジックの変更に合わせて、不要になった型定義を整理します。

以下の通り、ファイルを更新します。

```typescript
// ... existing code ...
interface ExtractedRecipe {
  title: string;
  ingredients: string[];
  steps: string[];
  servings?: string;
  cookingTime?: string;
  description: string;
  extractionMethod: 'gemini_text_analysis' | 'database';
}

// データベース保存用の型
type RecipeForDB = Omit<ExtractedRecipe, 'extractionMethod'> & {
  extractionMethod: 'gemini_text_analysis';
};

export async function GET(request: NextRequest) {
  try {
// ... existing code ...
    let extractedRecipe: ExtractedRecipe;

    // 3. Gemini APIが利用可能な場合はテキスト分析を試行
    if (geminiApiKey) {
      try {
        console.log('Gemini APIでテキスト分析を開始...');
        extractedRecipe = await analyzeTextWithGemini(
          videoDetails,
          geminiApiKey
        );
        console.log('Gemini APIでテキスト分析完了');
      } catch (geminiError) {
        console.error('Geminiテキスト分析失敗:', geminiError);
        return NextResponse.json(
          { error: 'AIによるレシピの抽出に失敗しました。' },
          { status: 500 }
        );
      }
    } else {
      // Gemini APIが利用できない場合はエラー
      console.error('Gemini APIキーが設定されていません。');
      return NextResponse.json(
        { error: 'レシピ抽出機能が設定されていません。' },
        { status: 500 }
      );
    }

    // 4. 分析結果をデータベースに保存 (ログインしている場合)
    if (user && videoDetails) {
// ... existing code ...
// ... existing code ...
  };
}

async function analyzeTextWithGemini(
  videoDetails: {
    title: string;
    description: string;
    channelTitle: string;
    thumbnail: string;
  },
  apiKey: string
): Promise<ExtractedRecipe> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const prompt = `
以下のYouTube料理動画のタイトルと説明文から、料理のレシピ情報を抽出してください。
動画の内容を正確に反映し、説明文に明示的に記載されている情報のみを使用してください。

タイトル: ${videoDetails.title}
説明文: ${videoDetails.description}
チャンネル名: ${videoDetails.channelTitle}

以下の形式でJSONで回答してください：
{
  "ingredients": [
    "材料名 分量単位",
    "例: 玉ねぎ 1個",
    "例: 醤油 大さじ2"
  ],
  "steps": [
    "手順1の詳細な説明",
    "手順2の詳細な説明"
  ],
  "servings": "何人分",
  "cookingTime": "調理時間（分）"
}

重要な指示：
1. 材料は具体的な分量と単位を含めて記載してください。
2. 手順は順序立てて、具体的に記載してください。
3. 提供されたタイトルと説明文の情報に基づき、明確に記載されている内容のみを抽出してください。
4. 記載されていない情報は推測で補完しないでください。
5. 日本語で回答してください。
6. レシピ情報が不足している場合でも、抽出できた部分のみを返却してください。
`;

  try {
    const result = await model.generateContent(prompt);
// ... existing code ...
    const text = response.text();

    // JSONレスポンスをパース
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('有効なJSONレスポンスが見つかりません');
    }

    const recipeData = JSON.parse(jsonMatch[0]);

    return {
      title: videoDetails.title,
      ingredients: recipeData.ingredients || [],
      steps: recipeData.steps || [],
      servings: recipeData.servings,
      cookingTime: recipeData.cookingTime,
      description: videoDetails.description,
      extractionMethod: 'gemini_text_analysis',
    };
  } catch (error) {
    console.error('Geminiテキスト分析エラー:', error);
    throw error;
  }
}

```

レシピ抽出ロジックの更新が完了しました。

主な変更点は以下の通りです。

-   **抽出ロジックを簡素化**:
    -   規約違反の可能性があった動画の直接分析機能 (`analyzeVideoWithGemini`) を削除しました。
    -   精度の低かった説明文からの単純なパース処理 (`extractRecipeFromDescription`) を削除しました。
    -   これにより、レシピ抽出は「**① データベース検索 → ② Geminiによるテキスト分析**」の2段階のフローに統一されました。
-   **プロンプトの改善**:
    -   `analyzeTextWithGemini` 関数のプロンプトを修正し、AIが情報を推測・補完するのではなく、提供されたテキストに忠実な情報のみを抽出するようにしました。これにより、より正確なレシピ情報が期待できます。
-   **コードのクリーンアップ**:
    -   不要になった関数や型定義を削除し、コード全体を整理しました。

この変更により、アプリケーションはYouTubeの利用規約を遵守し、より信頼性の高い方法でレシピを抽出できるようになりました。

今後、さらに精度を向上させたい場合は、YouTube Data APIから字幕（キャプション）データを取得し、それをGeminiの分析対象に加えることをお勧めします。

---

**User**

「YouTube Data API v3 → Gemini AI」の解説をして。

---

**Cursor**

はい、承知いたしました。
新しい「YouTube Data API v3 → Gemini AI」のレシピ抽出ロジックについて解説します。

この仕組みは、**YouTubeの利用規約を遵守し**、**AIの推測を排除して精度を高める**ことを目的としています。処理の流れは以下のようになります。

### ステップ1: YouTube Data API v3で動画情報を取得

まず、`getVideoDetails` 関数が YouTube Data API v3 を呼び出し、動画の公式な情報を取得します。

```typescript:src/app/api/youtube/extract-recipe/route.ts
async function getVideoDetails(videoId: string, apiKey: string) {
  const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${apiKey}`;
  const response = await fetch(detailsUrl);
  // ...
  const snippet = data.items[0].snippet;
  return {
    title: snippet.title,
    description: snippet.description,
    channelTitle: snippet.channelTitle,
    thumbnail: snippet.thumbnails.medium.url,
  };
}
```

-   **何を取得しているか？**:
    -   動画のタイトル (`title`)
    -   説明文 (`description`)
    -   チャンネル名 (`channelTitle`)
    -   サムネイル画像 (`thumbnail`)
-   **なぜ安全なのか？**:
    -   これはYouTubeが公式に提供しているAPIを利用した正規のアクセス方法です。動画ファイルそのものではなく、公開されているメタデータを取得しているため、利用規約に違反しません。

### ステップ2: 取得した情報を基に、Gemini AIへ指示を出す

次に、`analyzeTextWithGemini` 関数が、ステップ1で取得した情報（タイトルと説明文）を使って、Gemini AIにレシピの抽出を依頼します。

ここでのポイントは、**AIに与える「指示（プロンプト）」を厳密にした**ことです。

```typescript:src/app/api/youtube/extract-recipe/route.ts
// ...

  const prompt = `
以下のYouTube料理動画のタイトルと説明文から、料理のレシピ情報を抽出してください。
動画の内容を正確に反映し、説明文に明示的に記載されている情報のみを使用してください。

タイトル: ${videoDetails.title}
説明文: ${videoDetails.description}
チャンネル名: ${videoDetails.channelTitle}

以下の形式でJSONで回答してください：
// ... (JSON形式の指定) ...

重要な指示：
1. 材料は具体的な分量と単位を含めて記載してください。
2. 手順は順序立てて、具体的に記載してください。
3. 提供されたタイトルと説明文の情報に基づき、明確に記載されている内容のみを抽出してください。
4. 記載されていない情報は推測で補完しないでください。
5. 日本語で回答してください。
6. レシピ情報が不足している場合でも、抽出できた部分のみを返却してください。
`;

// ...
```

-   **AIへの指示のポイント**:
    -   **「明確に記載されている内容のみを抽出してください」**
    -   **「記載されていない情報は推測で補完しないでください」**
-   **この指示による効果**:
    -   以前のロジックでは、AIが情報不足を補うために「一般的なレシピ」を推測してしまい、実際の動画内容と異なるレシピが生成されることがありました。
    -   新しい指示では、この**推測を完全に禁止**し、説明文に書かれている情報だけを忠実に抜き出すように命令しています。これにより、レシピの**正確性**と**再現性**が大幅に向上します。

### ステップ3: Gemini AIからの返却データを整形

Gemini AIは、指示通りに抽出したレシピ情報をJSON形式で返します。アプリケーションはこれを受け取り、パースしてユーザーに表示します。また、この結果をデータベースに保存することで、同じ動画に対する次回以降のリクエストではAPIを呼び出すことなく、高速に結果を返すことができます。

### まとめ

新しい「YouTube Data API v3 → Gemini AI」のロジックは、

1.  **コンプライアンス**: YouTubeの公式APIのみを使用するため、**規約を遵守**している。
2.  **高精度**: AIの不要な推測を禁止し、**元情報に忠実なレシピ**を抽出する。
3.  **シンプルさ**: 複数の抽出ロジックを一本化し、**保守・管理がしやすい**構造になっている。

という利点があり、以前よりも信頼性の高いレシピ抽出機能となっています。

```typescript
async function getVideoDetails(videoId: string, apiKey: string) {
  const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${apiKey}`;
  const response = await fetch(detailsUrl);
  // ...
  const snippet = data.items[0].snippet;
  return {
    title: snippet.title,
    description: snippet.description,
    channelTitle: snippet.channelTitle,
    thumbnail: snippet.thumbnails.medium.url,
  };
}
```

```typescript
// ...

  const prompt = `
以下のYouTube料理動画のタイトルと説明文から、料理のレシピ情報を抽出してください。
動画の内容を正確に反映し、説明文に明示的に記載されている情報のみを使用してください。

タイトル: ${videoDetails.title}
説明文: ${videoDetails.description}
チャンネル名: ${videoDetails.channelTitle}

以下の形式でJSONで回答してください：
// ... (JSON形式の指定) ...

重要な指示：
1. 材料は具体的な分量と単位を含めて記載してください。
2. 手順は順序立てて、具体的に記載してください。
3. 提供されたタイトルと説明文の情報に基づき、明確に記載されている内容のみを抽出してください。
4. 記載されていない情報は推測で補完しないでください。
5. 日本語で回答してください。
6. レシピ情報が不足している場合でも、抽出できた部分のみを返却してください。
`;

// ...
```

---

**User**

ありがとう！
もし説明欄に材料、手順がなかった場合の対応は考えていますか？

ごめんなさい、説明欄に材料、手順が載ってなかったとアラートさせるなど

---

**Cursor**

素晴らしいご指摘ありがとうございます！まさにその通りで、説明欄に材料や手順が記載されていないケースは考慮すべき重要な点です。現在のロジックでは、その場合、中身が空のレシピが返ってきてしまい、ユーザーにとっては不便な挙動になってしまいます。

ご提案いただいた通り、**「説明欄に材料・手順が載っていなかった場合にアラートを出す」**という対応を実装しましょう。

具体的には、Gemini AIがレシピを抽出した直後に、**材料と手順のデータが両方とも空かどうかをサーバー側でチェック**します。もし空であれば、成功（HTTPステータス 200）として空のレシピを返すのではなく、**「抽出できませんでした」という明確なエラーメッセージと共に、クライアントがエラーとして扱えるHTTPステータス（例: 422 Unprocessable Entity）を返す**ようにします。

この変更により、

1.  **フロントエンドでの対応が容易に**: フロントエンド側でエラーを検知し、ご提案の通り「レシピ情報が見つかりませんでした」といったアラートを表示できます。
2.  **データベースの品質維持**: 中身が空の不完全なレシピデータがデータベースに保存されるのを防ぎます。

以下の通り、`src/app/api/youtube/extract-recipe/route.ts` を修正します。

```typescript
// ... existing code ...
        );
        console.log('Gemini APIでテキスト分析完了');
      } catch (geminiError) {
        console.error('Geminiテキスト分析失敗:', geminiError);
        return NextResponse.json(
          { error: 'AIによるレシピの抽出に失敗しました。' },
          { status: 500 }
        );
      }
    } else {
      // Gemini APIが利用できない場合はエラー
      console.error('Gemini APIキーが設定されていません。');
      return NextResponse.json(
        { error: 'レシピ抽出機能が設定されていません。' },
        { status: 500 }
      );
    }

    // 抽出結果の検証
    if (
      (extractedRecipe.ingredients && extractedRecipe.ingredients.length === 0) ||
      (extractedRecipe.steps && extractedRecipe.steps.length === 0)
    ) {
      return NextResponse.json(
        {
          error:
            '動画の説明欄からレシピ情報（材料と手順）を抽出できませんでした。',
        },
        { status: 422 }
      );
    }

    // 4. 分析結果をデータベースに保存 (ログインしている場合)
    if (user && videoDetails) {
      try {
// ... existing code ...

```

対応が完了しました。

`src/app/api/youtube/extract-recipe/route.ts` に、レシピ抽出結果を検証するロジックを追加しました。

これにより、Gemini AIがレシピを抽出した後に、材料または手順のどちらかが空だった場合、「動画の説明欄からレシピ情報（材料と手順）を抽出できませんでした。」というエラーメッセージを返すようになります。

このエラーをフロントエンド側で受け取って、ユーザーにアラートを表示する処理を実装することで、より親切なアプリケーションになりますね。

鋭いご指摘、ありがとうございました！

---

**User**

このエラーをフロントエンド側で受け取って、ユーザーにアラートを表示する処理を実装する

---

**Cursor**

はい、承知いたしました。
サーバーサイドで実装したエラーハンドリングを、今度はフロントエンド側で受け取ってユーザーにアラートを表示する処理を実装します。

まず、このAPIを呼び出しているフロントエンドのコンポーネントを特定する必要があります。ファイル構成から、レシピ管理やYouTube動画のURLを入力する機能を持つコンポーネントが関連している可能性が高いです。

APIエンドポイント `/api/youtube/extract-recipe` を使用している箇所を検索します。

検索の結果、3つのファイルでAPIが呼び出されていることがわかりました。
- `src/components/recipe-management.tsx`
- `src/components/cooking-management.tsx`
- `src/app/page.tsx`

これらのファイル全てに、エラーハンドリングのロジックを追加する必要があります。まず、最もメインのページである `src/app/page.tsx` から修正を始めましょう。

このファイルの内容を確認して、API呼び出し部分を特定し、エラーハンドリングを追加します。

ファイルの内容を読み込みました。 `src/app/page.tsx` の中の `VideoCard` コンポーネントがAPIを呼び出しているようです。

```typescript:src/app/page.tsx
// ...
  const handleExtractRecipe = async () => {
    setExtractingRecipe(true);
    try {
      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${video.videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        setExtractedRecipe(data.recipe);
        setShowRecipeDialog(true);
      } else {
        alert(data.error || 'レシピの抽出に失敗しました');
      }
    } catch (error) {
      console.error('Recipe extraction error:', error);
      alert('レシピの抽出中にエラーが発生しました');
    } finally {
      setExtractingRecipe(false);
    }
  };
// ...
```

この `handleExtractRecipe` 関数内の `else` ブロックで、既に `alert()` を使ったエラー表示が行われています。サーバーから返されるエラーメッセージ `data.error` をそのまま表示する実装になっているため、先日サーバーサイドに追加した「動画の説明欄からレシピ情報（材料と手順）を抽出できませんでした。」というメッセージも、この `alert` で表示されるはずです。

このままでも機能しますが、せっかく`shadcn/ui`を使っているので、より洗練されたUIにするために、`alert()` の代わりに `Alert` コンポーネントや、`Dialog` を使ってエラーメッセージを表示するようにリファクタリングすることも可能です。

今回は、まず `src/components/recipe-management.tsx` と `src/components/cooking-management.tsx` にも同様のエラーハンドリングが実装されているか確認し、不足している場合は追加しましょう。

まずは `src/components/recipe-management.tsx` を確認します。

```typescript
// ...
  const handleExtractRecipe = async () => {
    setExtractingRecipe(true);
    try {
      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${video.videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        setExtractedRecipe(data.recipe);
        setShowRecipeDialog(true);
      } else {
        alert(data.error || 'レシピの抽出に失敗しました');
      }
    } catch (error) {
      console.error('Recipe extraction error:', error);
      alert('レシピの抽出中にエラーが発生しました');
    } finally {
      setExtractingRecipe(false);
    }
  };
// ...
```

`src/components/recipe-management.tsx` を確認しました。

`handleExtractRecipe` という関数でAPIが呼び出されており、`src/app/page.tsx` と同様に、エラーが発生した場合は `alert()` でメッセージを表示する実装がすでに行われています。

```typescript:src/components/recipe-management.tsx
// ...
  const handleExtractRecipe = async (video: Video) => {
    // 対象動画のロード状態を設定
    setLoadingVideoId(video.id);
    try {
      // YouTube URLから動画IDを抽出
      const videoId = extractVideoId(video.url);
      if (!videoId) {
        throw new Error('動画IDの抽出に失敗しました');
      }

      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        setExtractedRecipe(data.recipe);
        setShowRecipeDialog(true);

        // 抽出済みリストに追加
        setExtractedVideoIds((prev) => new Set(prev).add(video.id));
      } else {
        alert(data.error || 'レシピの抽出に失敗しました');
      }
    } catch (error) {
      console.error('Recipe extraction error:', error);
      alert('レシピの抽出中にエラーが発生しました');
    } finally {
      // ロード状態をリセット
      setLoadingVideoId(null);
    }
  };
// ...
```

このコードにより、サーバーから返されたエラーメッセージがユーザーに通知されます。

最後に、`src/components/cooking-management.tsx` も確認して、同様の対応がされているか見てみましょう。

```typescript
// ...
  const handleExtractRecipe = async (video: Video) => {
    // 対象動画のロード状態を設定
    setLoadingVideoId(video.id);
    try {
      // YouTube URLから動画IDを抽出
      const videoId = extractVideoId(video.url);
      if (!videoId) {
        throw new Error('動画IDの抽出に失敗しました');
      }

      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        setExtractedRecipe(data.recipe);
        setShowRecipeDialog(true);

        // 抽出済みリストに追加
        setExtractedVideoIds((prev) => new Set(prev).add(video.id));
      } else {
        alert(data.error || 'レシピの抽出に失敗しました');
      }
    } catch (error) {
      console.error('Recipe extraction error:', error);
      alert('レシピの抽出中にエラーが発生しました');
    } finally {
      // ロード状態をリセット
      setLoadingVideoId(null);
    }
  };
// ...
```

```typescript
// ...
  const handleExtractRecipe = async (video: Video) => {
    // 対象動画のロード状態を設定
    setLoadingVideoId(video.id);
    try {
      // YouTube URLから動画IDを抽出
      const videoId = extractVideoId(video.url);
      if (!videoId) {
        throw new Error('動画IDの抽出に失敗しました');
      }

      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        setExtractedRecipe(data.recipe);
        setShowRecipeDialog(true);

        // 抽出済みリストに追加
        setExtractedVideoIds((prev) => new Set(prev).add(video.id));
      } else {
        alert(data.error || 'レシピの抽出に失敗しました');
      }
    } catch (error) {
      console.error('Recipe extraction error:', error);
      alert('レシピの抽出中にエラーが発生しました');
    } finally {
      // ロード状態をリセット
      setLoadingVideoId(null);
    }
  };
// ...
```

`src/components/cooking-management.tsx` を確認しました。
このファイルでも `analyzeRecipe` という関数内でAPI呼び出しが行われています。

```typescript:src/components/cooking-management.tsx
// ...
  const analyzeRecipe = async (
    video: RecipeVideo
  ): Promise<ExtractedRecipe | null> => {
    const videoId = extractVideoId(video.url);
    if (!videoId) return null;

    try {
      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        // ... (成功時の処理) ...
        return extractedRecipe;
      }
    } catch (error) {
      console.error('レシピ分析エラー:', error);
    }

    return null;
  };

  const startCooking = async (recipe: CookableRecipe) => {
    if (!recipe.extractedRecipe) {
      // レシピ分析が必要
      setAnalyzingVideoId(recipe.video.id);
      const extractedRecipe = await analyzeRecipe(recipe.video);
      setAnalyzingVideoId(null);

      if (!extractedRecipe) {
        alert('レシピの分析に失敗しました');
        return;
      }
      // ...
    }
    // ...
  };
// ...
```

`startCooking` 関数の中で `analyzeRecipe` が呼ばれ、レシピが取得できなかった場合 (`!extractedRecipe`) に `alert('レシピの分析に失敗しました');` という形でエラー表示が行われています。

しかし、この実装だと、サーバーから返ってきた具体的なエラーメッセージ（例：「説明欄からレシピが抽出できませんでした」）がユーザーに伝わりません。

そこで、`startCooking` 関数内のエラーハンドリングを修正し、APIからのエラーメッセージを正しく `alert` で表示するように変更します。

```typescript
// ...
  const analyzeRecipe = async (
    video: RecipeVideo
  ): Promise<ExtractedRecipe | null> => {
    const videoId = extractVideoId(video.url);
    if (!videoId) return null;

    try {
      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        // ... (成功時の処理) ...
        return extractedRecipe;
      }
    } catch (error) {
      console.error('レシピ分析エラー:', error);
    }

    return null;
  };

  const startCooking = async (recipe: CookableRecipe) => {
    if (!recipe.extractedRecipe) {
      // レシピ分析が必要
      setAnalyzingVideoId(recipe.video.id);
      const extractedRecipe = await analyzeRecipe(recipe.video);
      setAnalyzingVideoId(null);

      if (!extractedRecipe) {
        alert('レシピの分析に失敗しました');
        return;
      }
      // ...
    }
    // ...
  };
// ...
```

```typescript
// ...
  const analyzeRecipe = async (
    video: RecipeVideo
  ): Promise<ExtractedRecipe | null> => {
    const videoId = extractVideoId(video.url);
    if (!videoId) return null;

    try {
      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        // ... (成功時の処理) ...
        return extractedRecipe;
      }
    } catch (error) {
      console.error('レシピ分析エラー:', error);
    }

    return null;
  };

  const startCooking = async (recipe: CookableRecipe) => {
    if (!recipe.extractedRecipe) {
      // レシピ分析が必要
      setAnalyzingVideoId(recipe.video.id);
      const extractedRecipe = await analyzeRecipe(recipe.video);
      setAnalyzingVideoId(null);

      if (!extractedRecipe) {
        alert('レシピの分析に失敗しました');
        return;
      }
      // ...
    }
    // ...
  };
// ...
```

```typescriptreact
// ... existing code ...
  const analyzeRecipe = async (
    video: RecipeVideo
  ): Promise<{ recipe: ExtractedRecipe | null; error?: string }> => {
    const videoId = extractVideoId(video.url);
    if (!videoId) {
      return { recipe: null, error: '有効なYouTube URLではありません。' };
    }

    try {
      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        const extractedRecipe: ExtractedRecipe = {
          ...data.recipe,
          videoId,
        };

        // データベースに保存（テーブルが存在する場合のみ）
        if (user) {
          try {
            await supabase.from('extracted_recipes').upsert({
              user_id: user.id,
              video_id: videoId,
              title: extractedRecipe.title,
              ingredients: extractedRecipe.ingredients,
              steps: extractedRecipe.steps,
              servings: extractedRecipe.servings,
              cooking_time: extractedRecipe.cookingTime,
              description: extractedRecipe.description,
              extraction_method: extractedRecipe.extractionMethod,
              video_url: video.url,
              video_title: video.title,
              video_thumbnail: video.thumbnail,
            });
          } catch (error) {
            console.log(
              'レシピ分析結果の保存をスキップしました（テーブル未作成）:',
              error
            );
          }
        }

        return { recipe: extractedRecipe };
      } else {
        return { recipe: null, error: data.error };
      }
    } catch (error) {
      console.error('レシピ分析エラー:', error);
      return { recipe: null, error: 'レシピの分析中に不明なエラーが発生しました。' };
    }
  };

  const startCooking = async (recipe: CookableRecipe) => {
    if (!recipe.extractedRecipe) {
      // レシピ分析が必要
      setAnalyzingVideoId(recipe.video.id);
      const { recipe: extractedRecipe, error } = await analyzeRecipe(recipe.video);
      setAnalyzingVideoId(null);

      if (error || !extractedRecipe) {
        alert(error || 'レシピの分析に失敗しました');
        return;
      }

      recipe.extractedRecipe = extractedRecipe;
// ... existing code ...

```

`src/components/cooking-management.tsx` の修正が完了しました。

### 変更点

1.  **`analyzeRecipe` 関数の戻り値を変更**
    -   これまでは成功時にレシピ情報、失敗時に `null` を返していましたが、新しい実装では `{ recipe: ExtractedRecipe | null, error?: string }` というオブジェクトを返すようにしました。
    -   これにより、成功したデータと失敗時のエラーメッセージを明確に区別して扱えるようになります。
2.  **`startCooking` 関数のエラーハンドリングを強化**
    -   `analyzeRecipe` から返されたオブジェクトを受け取り、`error` プロパティが存在する場合、その内容を `alert()` で表示するように修正しました。
    -   これにより、APIから返却された「説明欄からレシピ情報が抽出できませんでした。」といった具体的なエラーメッセージをユーザーに伝えられるようになりました。

### まとめ

これで、以下の3つのファイル全てで、サーバーからのエラーメッセージをユーザーに正しく通知する仕組みが整いました。

-   `src/app/page.tsx`
-   `src/components/recipe-management.tsx`
-   `src/components/cooking-management.tsx`

ユーザーがレシピを抽出できない理由を明確に把握できるようになり、より使いやすいアプリケーションになったかと思います。

---

**User**

- アラートはSadcnuiを使って。

- 「抽出方法: 説明文から抽出」ここはもう書かなくていい。

- 材料 (6個)ではなく、材料(2人前)に変更して欲しい。

---

**Cursor**

承知いたしました。ご指摘いただいた3つの点を修正します。

1.  標準の `alert()` を、より見栄えの良い `shadcn/ui` の `Dialog` コンポーネントに変更してエラーを表示します。
2.  レシピ表示ダイアログから「抽出方法」の項目を削除します。
3.  材料の表示を「〇個」から、抽出できた場合は「〇人前」という表記に変更します。

まず、`src/app/page.tsx` の `VideoCard` コンポーネントから修正します。

```typescriptreact
// ... existing code ...
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogFooter,
  DialogDescription,
} from '@/components/ui/dialog';
import { ScrollArea } from '@/components/ui/scroll-area';
import { useState, useEffect } from 'react';
import Image from 'next/image';
import {
  Home,
  Package,
  ShoppingCart,
  BookOpen,
  Search,
  Plus,
  User,
  Utensils,
  Clock,
  Eye,
  FileText,
  Users,
  ExternalLink,
  AlertCircle,
  Save,
  List,
  LogOut,
  ChefHat,
  Download,
  Loader2,
  HelpCircle,
  AlertTriangle,
} from 'lucide-react';
import IngredientsManagement, {
  Ingredient,
} from '@/components/ingredients-management';
// ... existing code ...
function VideoCard({
  video,
  playlists,
  setPlaylists,
  onLoginRequired,
}: VideoCardProps) {
  const [showDescription, setShowDescription] = useState(false);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [showRecipeDialog, setShowRecipeDialog] = useState(false);
  const [selectedPlaylistId, setSelectedPlaylistId] = useState<string>('');
  const [showCreatePlaylist, setShowCreatePlaylist] = useState(false);
  const [newPlaylistName, setNewPlaylistName] = useState('');
  const [newPlaylistDescription, setNewPlaylistDescription] = useState('');
  const [extractedRecipe, setExtractedRecipe] =
    useState<ExtractedRecipe | null>(null);
  const [extractingRecipe, setExtractingRecipe] = useState(false);
  const [errorDialog, setErrorDialog] = useState<{
    open: boolean;
    message: string;
  }>({ open: false, message: '' });
  const { user } = useAuth();

  const handleSaveClick = () => {
    if (!user) {
// ... existing code ...
  };

  const handleExtractRecipe = async () => {
    setExtractingRecipe(true);
    setErrorDialog({ open: false, message: '' });
    try {
      const response = await fetch(
        `/api/youtube/extract-recipe?videoId=${video.videoId}`
      );
      const data = await response.json();

      if (response.ok) {
        setExtractedRecipe(data.recipe);
        setShowRecipeDialog(true);
      } else {
        setErrorDialog({
          open: true,
          message: data.error || 'レシピの抽出に失敗しました',
        });
      }
    } catch (error) {
      console.error('Recipe extraction error:', error);
      setErrorDialog({
        open: true,
        message: 'レシピの抽出中にエラーが発生しました',
      });
    } finally {
      setExtractingRecipe(false);
    }
  };

  const createNewPlaylist = async () => {
    if (!newPlaylistName.trim()) {
// ... existing code ...
              <DialogDescription>
                動画から抽出された材料と手順です
              </DialogDescription>
            </DialogHeader>
            {extractedRecipe && (
              <div className="space-y-6 py-4">
                {/* 基本情報 */}
                <div className="grid grid-cols-2 gap-4">
                  {extractedRecipe.servings && (
                    <div className="flex items-center gap-2">
                      <Users className="h-4 w-4 text-gray-600" />
                      <span className="text-sm">
                        {extractedRecipe.servings}
                      </span>
                    </div>
                  )}
                  {extractedRecipe.cookingTime && (
                    <div className="flex items-center gap-2">
                      <Clock className="h-4 w-4 text-gray-600" />
                      <span className="text-sm">
                        {extractedRecipe.cookingTime}
                      </span>
                    </div>
                  )}
                </div>

                {/* 材料 */}
                <div className="space-y-3">
                  <h4 className="flex items-center gap-2 font-semibold">
                    <Package className="h-4 w-4 text-green-600" />
                    材料 (
                    {extractedRecipe.servings ||
                      `${extractedRecipe.ingredients.length}個`}
                    )
                  </h4>
                  {extractedRecipe.ingredients.length > 0 ? (
                    <div className="grid gap-2">
                      {extractedRecipe.ingredients.map((ingredient, index) => (
                        <div
                          key={index}
                          className="flex items-center gap-2 rounded-lg border bg-green-50 p-3"
                        >
                          <span className="text-sm">{ingredient}</span>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <p className="text-sm text-gray-500">
                      材料が見つかりませんでした
                    </p>
                  )}
                </div>

                {/* 手順 */}
                <div className="space-y-3">
// ... existing code ...
                閉じる
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

        {/* エラー表示ダイアログ */}
        <Dialog
          open={errorDialog.open}
          onOpenChange={(open) => setErrorDialog({ ...errorDialog, open })}
        >
          <DialogContent>
            <DialogHeader>
              <DialogTitle className="flex items-center gap-2">
                <AlertTriangle className="h-6 w-6 text-red-500" />
                <span>レシピの取得に失敗しました</span>
              </DialogTitle>
              <DialogDescription className="pt-4">
                {errorDialog.message}
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button onClick={() => setErrorDialog({ open: false, message: '' })}>
                OK
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

        {/* 保存ダイアログ */}
        <Dialog open={showSaveDialog} onOpenChange={setShowSaveDialog}>
          <DialogContent className="max-w-md">
// ... existing code ...

```

`src/app/page.tsx` の修正が完了しました。

続いて、`src/components/recipe-management.tsx` にも同様の変更を適用します。

```typescriptreact
// ... existing code ...
import {
  Plus,
  List,
  Trash2,
  Edit,
  MoreVertical,
  Clock,
  Video,
  ShoppingCart,
  Download,
  Loader2,
  Package,
  AlertCircle,
  Users,
  Eye,
  Check,
  AlertTriangle,
} from 'lucide-react';
import {
  buttonVariants,
// ... existing code ...
  const [showRecipeDialog, setShowRecipeDialog] = useState(false);
  const [showShoppingDialog, setShowShoppingDialog] = useState(false);
  const [extractedRecipe, setExtractedRecipe] =
    useState<ExtractedRecipe | null>(null);
  const [loadingVideoId, setLoadingVideoId] = useState<string | null>(null);
  const [extractedVideoIds, setExtractedVideoIds] = useState<Set<string>>(
    new Set()
  );
  const [errorDialog, setErrorDialog] = useState<{
    open: boolean;
    message: string;
  }>({ open: false, message: '' });

  const getExtractionMethodText = (
    method: ExtractedRecipe['extractionMethod'] | undefined
// ... existing code ...
  const handleExtractRecipe = async (video: Video) => {
    // 対象動画のロード状態を設定
    setLoadingVideoId(video.id);
    setErrorDialog({ open: false, message: '' });
    try {
      // YouTube URLから動画IDを抽出
      const videoId = extractVideoId(video.url);
// ... existing code ...
        setExtractedVideoIds((prev) => new Set(prev).add(video.id));
      } else {
        setErrorDialog({
          open: true,
          message: data.error || 'レシピの抽出に失敗しました',
        });
      }
    } catch (error) {
      console.error('Recipe extraction error:', error);
      setErrorDialog({
        open: true,
        message: 'レシピの抽出中にエラーが発生しました',
      });
    } finally {
      // ロード状態をリセット
      setLoadingVideoId(null);
// ... existing code ...
                <div className="flex flex-col gap-3 rounded-lg border bg-gray-50 p-4 sm:flex-row sm:items-center sm:gap-6">
                  {extractedRecipe.servings && (
                    <div className="flex items-center gap-2">
                      <Users className="h-5 w-5 text-gray-500" />
                      <span className="text-sm font-medium">
                        {extractedRecipe.servings}
                      </span>
                    </div>
                  )}
                  {extractedRecipe.cookingTime && (
                    <div className="flex items-center gap-2">
                      <Clock className="h-5 w-5 text-gray-500" />
                      <span className="text-sm font-medium">
                        {extractedRecipe.cookingTime}
                      </span>
                    </div>
                  )}
                </div>

                {/* 材料 */}
                <div className="space-y-3">
                  <h4 className="flex items-center gap-2 text-base font-semibold">
                    <Package className="h-5 w-5 text-green-600" />
                    材料 (
                    {extractedRecipe.servings ||
                      `${extractedRecipe.ingredients.length}個`}
                    )
                  </h4>
                  {extractedRecipe.ingredients.length > 0 ? (
                    <div className="space-y-2">
                      {extractedRecipe.ingredients.map((ingredient, index) => (
// ... existing code ...
      <AddToShoppingListDialog
        isOpen={showShoppingDialog}
        onClose={() => setShowShoppingDialog(false)}
        extractedRecipe={extractedRecipe}
        onAddToShoppingList={handleAddToShoppingListInternal}
      />

      {/* エラー表示ダイアログ */}
      <Dialog
        open={errorDialog.open}
        onOpenChange={(open) => setErrorDialog({ ...errorDialog, open })}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <AlertTriangle className="h-6 w-6 text-red-500" />
              <span>レシピの取得に失敗しました</span>
            </DialogTitle>
            <DialogDescription className="pt-4">
              {errorDialog.message}
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button onClick={() => setErrorDialog({ open: false, message: '' })}>
              OK
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

```

`src/components/recipe-management.tsx` の修正が完了しました。

最後に、`src/components/cooking-management.tsx` にも同様の変更を適用します。このファイルにはレシピ表示のUIがないため、エラー表示の `Dialog` 化のみ行います。

```typescriptreact
// ... existing code ...
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog';

interface CookingManagementProps {
  ingredients: Ingredient[];
// ... existing code ...
  const [analyzingVideoId, setAnalyzingVideoId] = useState<string | null>(null);
  const [currentSession, setCurrentSession] = useState<CookingSession | null>(
    null
  );
  const [recipeDialogOpen, setRecipeDialogOpen] = useState(false);
  const [errorDialog, setErrorDialog] = useState<{
    open: boolean;
    message: string;
  }>({ open: false, message: '' });

  const { user } = useAuth();

  const loadPlaylists = useCallback(async () => {
// ... existing code ...
      // レシピ分析が必要
      setAnalyzingVideoId(recipe.video.id);
      const { recipe: extractedRecipe, error } = await analyzeRecipe(
        recipe.video
      );
      setAnalyzingVideoId(null);

      if (error || !extractedRecipe) {
        setErrorDialog({
          open: true,
          message: error || 'レシピの分析に失敗しました',
        });
        return;
      }

      recipe.extractedRecipe = extractedRecipe;
      recipe.matchedIngredients = matchIngredientsWithInventory(
// ... existing code ...
          </DialogHeader>
          <div className="flex-1 overflow-y-auto p-4">
            {!user ? (
              <Card>
// ... existing code ...
                onStartCooking={(recipe) => {
                  startCooking(recipe);
                  setRecipeDialogOpen(false);
                }}
                analyzingVideoId={analyzingVideoId}
              />
            )}
          </div>
        </DialogContent>
      </Dialog>

      {/* エラー表示ダイアログ */}
      <Dialog
        open={errorDialog.open}
        onOpenChange={(open) => setErrorDialog({ ...errorDialog, open })}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <AlertTriangle className="h-6 w-6 text-red-500" />
              <span>レシピの取得に失敗しました</span>
            </DialogTitle>
            <DialogDescription className="pt-4">
              {errorDialog.message}
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button onClick={() => setErrorDialog({ open: false, message: '' })}>
              OK
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// レシピリストコンポーネント
// ... existing code ...

```

すべての修正が完了しました。

### 変更のまとめ

-   **エラー表示の改善**:
    -   API呼び出しでエラーが発生した際、ブラウザ標準の `alert()` の代わりに、`shadcn/ui` の `Dialog` コンポーネントを使用して、統一感のあるUIでエラーメッセージを表示するようにしました。
-   **レシピ情報の表示を整理**:
    -   レシピ詳細ダイアログから、内部的な情報である「抽出方法」の表示を削除し、ユーザーにとってより分かりやすい表示にしました。
-   **材料表示の改善**:
    -   レシピに「〇人前」という情報がある場合はそれを表示し、ない場合は「〇個」と表示するようにして、より柔軟で直感的な材料表示を実現しました。

これらの変更により、アプリケーションの使い勝手と見た目が向上したかと思います。ご確認いただき、ありがとうございました！

